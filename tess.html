<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>v5</title>
<style>
  body {
    margin: 0;
    background-color: #000;
    font-family: Arial, sans-serif;
    color: white;
  }

  .ticker-container {
    position: fixed;
    bottom: 0;
    width: 100%;
    height: 40px;
    background: #111;
    overflow: hidden;
    display: flex;
    align-items: center;
  }

  .ticker-content {
    display: inline-block;
    white-space: nowrap;
    padding-left: 100%; /* start offscreen */
    animation-name: scroll-left;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
    animation-duration: 39s; /* slowed ~30% */
  }

  @keyframes scroll-left {
    from { transform: translateX(0); }
    to { transform: translateX(-100%); }
  }

  .chat {
    color: #00aaff; /* blue chat */
  }

  .news {
    color: #fff; /* white news */
  }
</style>
</head>
<body>

<div class="ticker-container">
  <div id="ticker" class="ticker-content"></div>
</div>

<script src="tmi.min.js"></script>
<script>
  const ticker = document.getElementById('ticker');
  const separator = '\u00A0\u00A0\u00A0\u00A0'; // 4 non-breaking spaces

  let headlines = [];
  let chatQueue = [];
  let displayedMessages = [];

  // Append new message to displayedMessages (removes old if too long)
  function appendMessage(text, type) {
    displayedMessages.push({ text, type });
    if(displayedMessages.length > 50) displayedMessages.shift();
  }

  // Render the ticker text
  function renderTicker() {
    // Format all displayed messages with spans and join with separator
    const html = displayedMessages.map(msg => {
      const safeText = msg.text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      return `<span class="${msg.type}">${safeText}</span>`;
    }).join(separator);
    ticker.innerHTML = html;
  }

  // Initially populate displayedMessages with headlines only
  function initHeadlines() {
    displayedMessages = headlines.map(h => ({ text: h, type: 'news' }));
    renderTicker();
  }

  // Inject chat messages smoothly, one at a time, every ~1.5s
  function processChatQueue() {
    if(chatQueue.length > 0) {
      // Insert next chat message just offscreen by pushing to displayedMessages
      appendMessage(chatQueue.shift(), 'chat');
      renderTicker();
    }
  }

  // Start interval to inject chat messages regularly
  setInterval(processChatQueue, 1500);

  // Twitch chat setup
  const client = new tmi.Client({
    channels: ['1dustin2gray']
  });

  client.connect().catch(console.error);

  client.on('message', (channel, tags, message, self) => {
    if(self) return;
    const chatMsg = `${tags['display-name']}: ${message}`;
    chatQueue.push(chatMsg);
  });

  // Fetch NYT headlines & update headlines array
  const feeds = [
    {
      name: "NYT Politics",
      url: "https://api.rss2json.com/v1/api.json?rss_url=https://rss.nytimes.com/services/xml/rss/nyt/Politics.xml"
    },
    {
      name: "NYT World",
      url: "https://api.rss2json.com/v1/api.json?rss_url=https://rss.nytimes.com/services/xml/rss/nyt/World.xml"
    }
  ];

  async function fetchHeadlines() {
    let combined = [];
    for(const feed of feeds) {
      try {
        const res = await fetch(feed.url);
        const data = await res.json();
        const newHeads = data.items.slice(0,3).map(item => `${feed.name}: ${item.title}`);
        combined = combined.concat(newHeads);
      } catch(e) {
        console.error(`Error fetching ${feed.name}`, e);
      }
    }
    headlines = combined;
    initHeadlines();
  }

  fetchHeadlines();
  setInterval(fetchHeadlines, 5 * 60 * 1000);

  // Start with loading message
  ticker.innerHTML = '<span class="news">Connecting to Twitch chat and news...</span>';
</script>

</body>
</html>
